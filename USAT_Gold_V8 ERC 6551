// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

contract USATGoldExchange is Initializable, ERC721URIStorageUpgradeable, ERC1155SupplyUpgradeable, ReentrancyGuardUpgradeable, AccessControlUpgradeable, UUPSUpgradeable {
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant FRACTIONALIZER_ROLE = keccak256("FRACTIONALIZER_ROLE");

    struct GoldAsset {
        uint256 id;
        uint256 amount; // For ERC1155, amount represents the supply of the fractional tokens
        string metadataURI;
        bool isFractional;
    }

    uint256 private _currentTokenID;
    mapping(uint256 => GoldAsset) public goldAssets;
    mapping(address => uint256) public pendingWithdrawals; // For handling sales proceeds

    event GoldAssetMinted(uint256 indexed tokenId, address indexed minter, string uri, bool isFractional);
    event SaleProceedsWithdrawn(address indexed withdrawer, uint256 amount);

    function initialize(string memory uri) public initializer {
        __ERC721_init("USATGoldToken", "UGT");
        __ERC1155_init(uri);
        __ReentrancyGuard_init();
        __AccessControl_init();
        __UUPSUpgradeable_init();

        _setupRole(ADMIN_ROLE, msg.sender);
        _setRoleAdmin(MINTER_ROLE, ADMIN_ROLE);
        _setRoleAdmin(FRACTIONALIZER_ROLE, ADMIN_ROLE);

        _currentTokenID = 0;
    }

    function mintUniqueGoldAsset(string calldata metadataURI) public onlyRole(MINTER_ROLE) returns (uint256) {
        _currentTokenID++;
        _mint(msg.sender, _currentTokenID);
        _setTokenURI(_currentTokenID, metadataURI);

        GoldAsset memory newAsset = GoldAsset({
            id: _currentTokenID,
            amount: 1,
            metadataURI: metadataURI,
            isFractional: false
        });

        goldAssets[_currentTokenID] = newAsset;
        emit GoldAssetMinted(_currentTokenID, msg.sender, metadataURI, false);
        return _currentTokenID;
    }

    function mintFractionalGoldAsset(uint256 amount, string calldata metadataURI) public onlyRole(MINTER_ROLE) returns (uint256) {
        _currentTokenID++;
        _mint(msg.sender, _currentTokenID, amount, "");

        GoldAsset memory newAsset = GoldAsset({
            id: _currentTokenID,
            amount: amount,
            metadataURI: metadataURI,
            isFractional: true
        });

        goldAssets[_currentTokenID] = newAsset;
        emit GoldAssetMinted(_currentTokenID, msg.sender, metadataURI, true);
        return _currentTokenID;
    }

    function buyGoldAsset(uint256 tokenId, uint256 amount) public payable nonReentrant {
        require(goldAssets[tokenId].isFractional, "Asset must be fractional for direct purchase.");
        require(amount <= balanceOf(address(this), tokenId), "Not enough tokens available for sale.");
        uint256 salePrice = goldAssets[tokenId].amount * amount; // Simplified pricing model
        require(msg.value >= salePrice, "Insufficient payment.");

        // Transfer tokens to buyer
        _safeTransferFrom(address(this), msg.sender, tokenId, amount, "");

        // Update seller's pending withdrawals
        pendingWithdrawals[msg.sender] += msg.value;
    }

    function withdrawProceeds() public nonReentrant {
        uint256 amount = pendingWithdrawals[msg.sender];
        require(amount > 0, "No proceeds to withdraw.");

        pendingWithdrawals[msg.sender] = 0;
        (bool success,) = msg.sender.call{value: amount}("");
        require(success, "Withdrawal failed.");

        emit SaleProceedsWithdrawn(msg.sender, amount);
    }

    function _authorizeUpgrade(address newImplementation) internal override onlyRole(ADMIN_ROLE) {}

    // Additional contract logic such as bid handling, token-bound account functionalities, etc.

    // NOTE: This is a simplified example. Real-world use would require more robust pricing, security checks, and functionality.
}
